<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phosphenes — EEG for LLMs</title>
<style>
/* ══════════════════════════════════════════════════════════
   BASE STYLES
   ══════════════════════════════════════════════════════════ */
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg: #0b0b12;
    --bg-panel: rgba(11, 11, 18, 0.92);
    --text: #e6e6f0;
    --dim: #78788c;
    --amber: #ffc864;
    --soft-amber: #c8a050;
    --user-color: #78b4ff;
    --assistant-color: #ffc864;
    --system-color: #646478;
}

body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Menlo', 'SF Mono', 'Consolas', 'Monaco', monospace;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    cursor: crosshair;
    user-select: none;
    -webkit-user-select: none;
}

/* ══════════════════════════════════════════════════════════
   LAYOUT
   ══════════════════════════════════════════════════════════ */
#app {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
}

#header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 16px;
    height: 36px;
    min-height: 36px;
    background: rgba(11, 11, 18, 0.95);
    border-bottom: 1px solid rgba(255, 200, 100, 0.15);
    z-index: 10;
}

#header-left {
    display: flex;
    align-items: center;
    gap: 16px;
}

#header h1 {
    font-size: 14px;
    font-weight: 600;
    color: var(--amber);
    letter-spacing: 1px;
}

#session-name {
    font-size: 12px;
    color: var(--dim);
}

#header-right {
    display: flex;
    align-items: center;
    gap: 16px;
    font-size: 11px;
    color: var(--dim);
}

#speed-display, #position-display {
    min-width: 80px;
}

#mode-display {
    color: var(--amber);
    min-width: 60px;
}

#main-area {
    display: flex;
    flex: 1;
    overflow: hidden;
    position: relative;
}

#canvas-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
}

/* Role bar above canvas */
#role-bar {
    height: 12px;
    min-height: 12px;
    position: relative;
    background: transparent;
}

#canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
}

canvas#viz {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: auto;
}

/* Token strip below canvas (when paused) */
#token-strip {
    height: 32px;
    min-height: 32px;
    background: var(--bg-panel);
    border-top: 1px solid rgba(255, 200, 100, 0.1);
    display: flex;
    align-items: center;
    padding: 0 16px;
    font-size: 11px;
    overflow: hidden;
    white-space: nowrap;
}

#token-strip.hidden { display: none; }

/* ══════════════════════════════════════════════════════════
   TEXT PANEL (right side)
   ══════════════════════════════════════════════════════════ */
#text-panel {
    width: 280px;
    min-width: 280px;
    background: var(--bg-panel);
    border-left: 1px solid rgba(120, 180, 255, 0.1);
    overflow-y: auto;
    padding: 8px 12px;
    font-size: 13px;
    line-height: 1.5;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,200,100,0.2) transparent;
}

#text-panel.hidden { display: none; width: 0; min-width: 0; }

#text-panel::-webkit-scrollbar { width: 4px; }
#text-panel::-webkit-scrollbar-thumb { background: rgba(255,200,100,0.2); border-radius: 2px; }

.token-span {
    transition: opacity 0.15s;
}

.token-span.current {
    color: #fff !important;
    text-decoration: underline;
    text-underline-offset: 2px;
}

.token-span.user { color: var(--user-color); }
.token-span.assistant { color: var(--assistant-color); }
.token-span.system { color: var(--system-color); }
.token-span.default { color: #b4b4c8; }

/* ══════════════════════════════════════════════════════════
   INSPECTOR TOOLTIP
   ══════════════════════════════════════════════════════════ */
#inspector {
    position: fixed;
    background: rgba(15, 15, 25, 0.93);
    border: 1px solid var(--amber);
    border-radius: 4px;
    padding: 8px 10px;
    font-size: 11px;
    line-height: 1.5;
    pointer-events: none;
    z-index: 100;
    display: none;
    min-width: 160px;
    backdrop-filter: blur(4px);
}

#inspector .label { color: var(--amber); font-weight: 600; }
#inspector .value { color: var(--text); }

/* ══════════════════════════════════════════════════════════
   COLOR BASIS OVERLAY / STATUS
   ══════════════════════════════════════════════════════════ */
#color-basis-status {
    position: fixed;
    bottom: 48px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(15, 15, 25, 0.93);
    border: 1px solid var(--amber);
    border-radius: 6px;
    padding: 8px 20px;
    font-size: 12px;
    color: var(--amber);
    z-index: 50;
    display: none;
    text-align: center;
    backdrop-filter: blur(4px);
}

/* ══════════════════════════════════════════════════════════
   LOADING OVERLAY
   ══════════════════════════════════════════════════════════ */
#loading {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    gap: 16px;
}

#loading h2 {
    color: var(--amber);
    font-size: 18px;
    font-weight: 400;
    letter-spacing: 2px;
}

#loading-status {
    color: var(--dim);
    font-size: 12px;
}

#loading.hidden { display: none; }

/* ══════════════════════════════════════════════════════════
   HELP OVERLAY
   ══════════════════════════════════════════════════════════ */
#help-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11, 11, 18, 0.96);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 150;
}

#help-overlay.hidden { display: none; }

#help-content {
    max-width: 600px;
    padding: 32px 40px;
    font-size: 13px;
    line-height: 1.8;
}

#help-content h2 {
    color: var(--amber);
    font-size: 16px;
    margin-bottom: 16px;
    letter-spacing: 1px;
}

#help-content .key {
    display: inline-block;
    min-width: 70px;
    color: var(--amber);
}

#help-content .section {
    margin-top: 16px;
    color: var(--user-color);
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

#help-content .note {
    margin-top: 20px;
    color: var(--dim);
    font-size: 11px;
    font-style: italic;
}

/* ══════════════════════════════════════════════════════════
   SESSION PICKER
   ══════════════════════════════════════════════════════════ */
#session-picker {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11, 11, 18, 0.96);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 150;
}

#session-picker.hidden { display: none; }

#session-list {
    max-width: 500px;
    padding: 32px 40px;
}

#session-list h2 {
    color: var(--amber);
    font-size: 16px;
    margin-bottom: 16px;
    letter-spacing: 1px;
}

.session-item {
    padding: 8px 12px;
    margin: 4px 0;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: background 0.15s;
}

.session-item:hover { background: rgba(255, 200, 100, 0.08); }
.session-item.active { background: rgba(255, 200, 100, 0.15); }

.session-item .num {
    color: var(--amber);
    font-weight: 600;
    min-width: 20px;
}

.session-item .name { color: var(--text); font-size: 13px; }
.session-item .info { color: var(--dim); font-size: 11px; margin-left: auto; }
</style>
</head>
<body>

<div id="app">
    <div id="header">
        <div id="header-left">
            <h1>PHOSPHENES</h1>
            <span id="session-name"></span>
        </div>
        <div id="header-right">
            <span id="mode-display"></span>
            <span id="speed-display"></span>
            <span id="position-display"></span>
            <span style="color:var(--dim); cursor:pointer;" onclick="toggleHelp()" title="Help">H:help</span>
        </div>
    </div>

    <div id="main-area">
        <div id="canvas-container">
            <div id="role-bar"></div>
            <div id="canvas-wrapper">
                <canvas id="viz"></canvas>
            </div>
            <div id="token-strip" class="hidden"></div>
        </div>
        <div id="text-panel"></div>
    </div>
</div>

<div id="inspector"></div>
<div id="color-basis-status"></div>

<div id="loading">
    <h2>PHOSPHENES</h2>
    <div id="loading-status">Loading session index...</div>
</div>

<div id="help-overlay" class="hidden">
    <div id="help-content">
        <h2>Phosphenes Controls</h2>
        <div class="section">Playback</div>
        <div><span class="key">Space</span> Play / Pause</div>
        <div><span class="key">&larr; &rarr;</span> Step back / forward one token</div>
        <div><span class="key">&uarr; &darr;</span> Speed up / slow down</div>
        <div class="section">Visualization</div>
        <div><span class="key">M</span> Cycle metric: off &rarr; energy &rarr; sparsity</div>
        <div><span class="key">P</span> Reference point mode (click a cell)</div>
        <div><span class="key">C</span> Custom color basis mode</div>
        <div><span class="key">I</span> Toggle inspector (hover for values)</div>
        <div class="section">Navigation</div>
        <div><span class="key">1-8</span> Switch dream session</div>
        <div><span class="key">S</span> Session picker</div>
        <div><span class="key">Tab</span> Toggle text panel</div>
        <div><span class="key">T</span> Toggle turn markers</div>
        <div><span class="key">H</span> Toggle this help</div>
        <div class="section">Color Basis Mode</div>
        <div><span class="key">Click</span> Add source cell</div>
        <div><span class="key">Shift+Click</span> Add contrast cell</div>
        <div><span class="key">Enter</span> Confirm axis / finalize</div>
        <div><span class="key">Z</span> Undo last cell</div>
        <div><span class="key">Esc</span> Cancel</div>
        <div class="note">Phosphenes visualizes the internal activation states of Qwen3-VL-32B during creative text generation. Each column is a token, each row a transformer layer. Color = position in the principal subspace of the residual stream.</div>
    </div>
</div>

<div id="session-picker" class="hidden">
    <div id="session-list">
        <h2>Dream Sessions</h2>
    </div>
</div>

<script>
/* ══════════════════════════════════════════════════════════
   PHOSPHENES WEB — Main Application
   ══════════════════════════════════════════════════════════ */

// --- Constants ---
const TOKENS_VISIBLE = 160;
const CELL_PX = 8;
const CELL_PY = 14;
const DEFAULT_TPS = 24;
const BG = [11, 11, 18];

// Effect params
const ENERGY_FLOOR = 0.15;
const ENERGY_CEIL = 1.0;
const SEAM_GLOW_INTENSITY = 0.55;
const SEAM_GLOW_COLOR = [1.0, 0.88, 0.65];
const TURBULENCE_AMP = 0.16;
const TURBULENCE_SPEED = 2.5;
const GRAIN_MAX = 0.12;

// --- Global State ---
let sessions = [];
let currentSessionIdx = 0;
let data = null;  // current session data (decoded)

// Playback
let playing = true;
let tokenCursor = 0;
let playbackSpeed = 1.0;
let tokensPerSecond = DEFAULT_TPS;
let lastFrameTime = 0;

// Modes
let highlightMode = null;  // null | "energy" | "sparsity"
let highlightIdx = 0;
const HIGHLIGHT_MODES = [null, "energy", "sparsity"];

let showTurnMarkers = true;
let showTextPanel = true;
let showInspector = true;
let showHelp = false;
let showSessionPicker = false;

// Reference point mode
let refMode = false;
let refToken = null;
let refLayer = null;
let refDistances = null;

// Color basis mode
let colorBasisMode = false;
let colorBasisSelecting = false;
let colorBasisCurrentIdx = 0;
let colorBasisGroups = [];
let colorBasisResult = null;
let colorBasisGuidance = null;

// Inspector
let inspectorToken = null;
let inspectorLayer = null;

// Animation
let turbulencePhase = 0;
let grainPhase = 0;

// Pre-generated noise textures
let noiseTextures = [];
let grainTextures = [];

// Canvas
const canvas = document.getElementById('viz');
const ctx = canvas.getContext('2d', { alpha: false });
let canvasRect = { x: 0, y: 0, w: 0, h: 0 };
let vizGeom = { xOff: 0, yOff: 0, w: 0, h: 0 };

// Offscreen canvas for cell-resolution rendering
const offCanvas = document.createElement('canvas');
offCanvas.width = TOKENS_VISIBLE;
offCanvas.height = 64;
const offCtx = offCanvas.getContext('2d', { alpha: false });
let offImageData = null;

// Rendering cache
let cachedTEnd = -1;
let cachedModeHash = '';
let cachedBaseRGB = null;  // Float32Array (L * W * 3)

/* ══════════════════════════════════════════════════════════
   DATA LOADING & DECODING
   ══════════════════════════════════════════════════════════ */

function decodeBase64ToUint8(b64) {
    const binary = atob(b64);
    const arr = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        arr[i] = binary.charCodeAt(i);
    }
    return arr;
}

function dequantizeJL(quantized, jlMin, jlMax, T, L, D) {
    // quantized: Uint8Array (T*L*D), jlMin/jlMax: Float32Array (D)
    const spread = new Float32Array(D);
    for (let d = 0; d < D; d++) spread[d] = jlMax[d] - jlMin[d];

    const result = new Float32Array(T * L * D);
    for (let i = 0; i < T * L; i++) {
        const offset = i * D;
        for (let d = 0; d < D; d++) {
            result[offset + d] = (quantized[offset + d] / 255.0) * spread[d] + jlMin[d];
        }
    }
    return result;
}

async function loadSessionIndex() {
    const resp = await fetch('data/sessions.json');
    const idx = await resp.json();
    sessions = idx.sessions;
}

async function loadSession(sessionIdx) {
    const info = sessions[sessionIdx];
    document.getElementById('loading-status').textContent = `Loading ${info.display_name}...`;
    document.getElementById('loading').classList.remove('hidden');

    const resp = await fetch(`data/${info.file}`);
    const raw = await resp.json();

    const T = raw.n_tokens;
    const L = raw.n_layers;
    const D = raw.jl_dim;

    // Decode binary arrays
    const rgb = decodeBase64ToUint8(raw.rgb);              // T*L*3
    const jlQ = decodeBase64ToUint8(raw.jl);               // T*L*D
    const energyNorm = decodeBase64ToUint8(raw.energy_norm); // T*L
    const deltaNorm = decodeBase64ToUint8(raw.delta_norm);   // T*L
    const cosInstability = decodeBase64ToUint8(raw.cos_instability); // T*L
    const sparsityNorm = decodeBase64ToUint8(raw.sparsity_norm);     // T*L
    const seamScore = decodeBase64ToUint8(raw.seam_score);   // T

    // Dequantize JL vectors
    const jlMin = new Float32Array(raw.jl_min);
    const jlMax = new Float32Array(raw.jl_max);
    const jl = dequantizeJL(jlQ, jlMin, jlMax, T, L, D);

    data = {
        stem: raw.stem,
        displayName: raw.display_name,
        T, L, D,
        rgb,
        jl,
        energyNorm,
        deltaNorm,
        cosInstability,
        sparsityNorm,
        seamScore,
        tokenPieces: raw.token_pieces,
        tokenRoles: raw.token_roles,
        turns: raw.turns || [],
    };

    currentSessionIdx = sessionIdx;
    tokenCursor = 0;
    playing = true;
    cachedTEnd = -1;
    cachedBaseRGB = null;

    // Reset modes
    refMode = false;
    refDistances = null;
    colorBasisMode = false;
    colorBasisSelecting = false;
    colorBasisGroups = [];
    colorBasisResult = null;
    colorBasisGuidance = null;

    // Generate noise textures
    generateNoiseTextures(L);

    // Update UI
    updateSessionName();
    buildTextPanel();
    buildSessionPicker();

    document.getElementById('loading').classList.add('hidden');
}

/* ══════════════════════════════════════════════════════════
   NOISE TEXTURE GENERATION
   ══════════════════════════════════════════════════════════ */

function seededRandom(seed) {
    // Simple mulberry32 PRNG
    return function() {
        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function gaussianRandom(rng) {
    // Box-Muller
    let u, v, s;
    do {
        u = rng() * 2 - 1;
        v = rng() * 2 - 1;
        s = u * u + v * v;
    } while (s >= 1 || s === 0);
    return u * Math.sqrt(-2 * Math.log(s) / s);
}

function generateNoiseTextures(L) {
    const W = TOKENS_VISIBLE;
    noiseTextures = [];
    grainTextures = [];

    // Simple smoothed noise for turbulence
    let rng = seededRandom(7);
    for (let n = 0; n < 4; n++) {
        const tex = new Float32Array(L * W);
        for (let i = 0; i < L * W; i++) {
            tex[i] = gaussianRandom(rng);
        }
        // Simple box blur (approximate Gaussian sigma=1.8)
        const blurred = boxBlur2D(tex, L, W, 2);
        // Normalize
        let sum = 0, sum2 = 0;
        for (let i = 0; i < blurred.length; i++) { sum += blurred[i]; sum2 += blurred[i] * blurred[i]; }
        const mean = sum / blurred.length;
        const std = Math.sqrt(sum2 / blurred.length - mean * mean) + 1e-6;
        for (let i = 0; i < blurred.length; i++) blurred[i] = (blurred[i] - mean) / std;
        noiseTextures.push(blurred);
    }

    // Grain textures (unsmoothed)
    rng = seededRandom(13);
    for (let n = 0; n < 8; n++) {
        const tex = new Float32Array(L * W);
        for (let i = 0; i < L * W; i++) {
            tex[i] = gaussianRandom(rng);
        }
        grainTextures.push(tex);
    }
}

function boxBlur2D(arr, rows, cols, radius) {
    const result = new Float32Array(arr.length);
    // Horizontal pass
    const temp = new Float32Array(arr.length);
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let sum = 0, count = 0;
            for (let dc = -radius; dc <= radius; dc++) {
                const cc = c + dc;
                if (cc >= 0 && cc < cols) {
                    sum += arr[r * cols + cc];
                    count++;
                }
            }
            temp[r * cols + c] = sum / count;
        }
    }
    // Vertical pass
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let sum = 0, count = 0;
            for (let dr = -radius; dr <= radius; dr++) {
                const rr = r + dr;
                if (rr >= 0 && rr < rows) {
                    sum += temp[rr * cols + c];
                    count++;
                }
            }
            result[r * cols + c] = sum / count;
        }
    }
    return result;
}

/* ══════════════════════════════════════════════════════════
   RENDERING
   ══════════════════════════════════════════════════════════ */

function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    const rect = wrapper.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);

    canvasRect = { x: rect.left, y: rect.top, w: rect.width, h: rect.height };

    // Resize offscreen canvas if layer count changed
    if (data) {
        offCanvas.width = TOKENS_VISIBLE;
        offCanvas.height = data.L;
        offImageData = null;
    }

    cachedTEnd = -1;
    cachedBaseRGB = null;
}

function getModeHash() {
    return `${highlightMode}|${refMode}|${refToken}|${refLayer}|${colorBasisMode}|${colorBasisSelecting}|${colorBasisCurrentIdx}|${colorBasisResult ? 'yes' : 'no'}|${colorBasisGuidance ? 'yes' : 'no'}`;
}

function renderFrame(timestamp) {
    if (!data) { requestAnimationFrame(renderFrame); return; }

    const dt = lastFrameTime ? (timestamp - lastFrameTime) / 1000 : 0;
    lastFrameTime = timestamp;

    // Advance playback
    if (playing) {
        tokenCursor += tokensPerSecond * playbackSpeed * dt;
        if (tokenCursor >= data.T - 1) {
            tokenCursor = 0; // loop
        }
    }

    // Advance animation phases
    turbulencePhase += TURBULENCE_SPEED * dt;
    grainPhase += 3.0 * dt;

    const { T, L, D } = data;
    const W = TOKENS_VISIBLE;

    // Determine window
    const tEnd = Math.min(Math.floor(tokenCursor), T - 1);
    const tStart = Math.max(0, tEnd - W + 1);
    const span = tEnd - tStart + 1;
    const padLeft = W - span;

    // Check cache
    const modeHash = getModeHash();
    const cacheValid = (tEnd === cachedTEnd && modeHash === cachedModeHash && cachedBaseRGB !== null);

    let rgb;
    if (cacheValid) {
        rgb = new Float32Array(cachedBaseRGB);
    } else {
        rgb = computeBaseRGB(tStart, tEnd, padLeft, W, L, T, D);
        cachedBaseRGB = new Float32Array(rgb);
        cachedTEnd = tEnd;
        cachedModeHash = modeHash;
    }

    // --- Overlay effects (every frame) ---
    applyTurbulence(rgb, tStart, tEnd, padLeft, W, L);
    applyGrain(rgb, tStart, tEnd, padLeft, W, L);

    // Clamp
    for (let i = 0; i < rgb.length; i++) {
        rgb[i] = Math.max(0, Math.min(1, rgb[i]));
    }

    // --- Render to offscreen canvas at cell resolution (W x L) ---
    if (offCanvas.width !== W || offCanvas.height !== L) {
        offCanvas.width = W;
        offCanvas.height = L;
        offImageData = null;
    }
    if (!offImageData || offImageData.width !== W || offImageData.height !== L) {
        offImageData = offCtx.createImageData(W, L);
    }

    const pixels = offImageData.data;
    for (let row = 0; row < L; row++) {
        for (let col = 0; col < W; col++) {
            const rgbIdx = (row * W + col) * 3;
            const pIdx = (row * W + col) * 4;
            pixels[pIdx]     = Math.floor(rgb[rgbIdx] * 255);
            pixels[pIdx + 1] = Math.floor(rgb[rgbIdx + 1] * 255);
            pixels[pIdx + 2] = Math.floor(rgb[rgbIdx + 2] * 255);
            pixels[pIdx + 3] = 255;
        }
    }
    offCtx.putImageData(offImageData, 0, 0);

    // --- Draw to main canvas with DPR-aware scaling ---
    const dpr = window.devicePixelRatio || 1;
    const dispW = canvasRect.w;
    const dispH = canvasRect.h;

    ctx.save();
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);  // scale for HiDPI

    // Clear background
    ctx.fillStyle = `rgb(${BG[0]},${BG[1]},${BG[2]})`;
    ctx.fillRect(0, 0, dispW, dispH);

    // Calculate display area maintaining cell aspect ratio
    const cellAspect = (W * CELL_PX) / (L * CELL_PY);
    let vizW, vizH;
    if (dispW / dispH > cellAspect) {
        vizH = dispH;
        vizW = vizH * cellAspect;
    } else {
        vizW = dispW;
        vizH = vizW / cellAspect;
    }
    const vizX = (dispW - vizW) / 2;
    const vizY = (dispH - vizH) / 2;

    vizGeom = { xOff: vizX, yOff: vizY, w: vizW, h: vizH, tStart, tEnd, padLeft };

    // Draw offscreen canvas scaled up with bilinear smoothing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(offCanvas, 0, 0, W, L, vizX, vizY, vizW, vizH);

    // --- Overlays drawn with Canvas API (in CSS-pixel coordinates) ---
    const cellWScaled = vizW / W;
    const cellHScaled = vizH / L;

    // Playhead line
    const playheadCol = padLeft + (tEnd - tStart);
    const playheadX = vizX + playheadCol * cellWScaled;
    ctx.strokeStyle = 'rgba(255, 200, 100, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(playheadX, vizY);
    ctx.lineTo(playheadX, vizY + vizH);
    ctx.stroke();

    // Turn marker lines
    if (showTurnMarkers && data.turns.length > 0) {
        renderTurnMarkers(vizX, vizY, vizW, vizH, cellWScaled, tStart, tEnd, padLeft, W, L);
    }

    // Color basis cell markers
    if (colorBasisGroups.length > 0) {
        renderColorBasisMarkers(vizX, vizY, cellWScaled, cellHScaled, tStart, tEnd, padLeft, L);
    }

    // Inspector crosshairs
    if (showInspector && inspectorToken !== null && inspectorLayer !== null) {
        renderInspectorCrosshairs(vizX, vizY, vizW, vizH, cellWScaled, cellHScaled, tStart, tEnd, padLeft, L);
    }

    ctx.restore();

    // Update UI
    updateHeader();
    updateRoleBar(vizX, vizW, cellWScaled, tStart, tEnd, padLeft, W, L);
    updateTokenStrip(tEnd);
    scrollTextPanel(tStart, tEnd);
    updateColorBasisStatus();

    requestAnimationFrame(renderFrame);
}

function computeBaseRGB(tStart, tEnd, padLeft, W, L, T, D) {
    const rgb = new Float32Array(L * W * 3);

    // Extract PCA RGB window with energy brightness
    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;

        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;  // layer 0 at bottom
            const srcIdx = (tokenIdx * L + layer) * 3;
            const dstIdx = (row * W + col) * 3;

            let r = data.rgb[srcIdx] / 255.0;
            let g = data.rgb[srcIdx + 1] / 255.0;
            let b = data.rgb[srcIdx + 2] / 255.0;

            // Energy brightness modulation
            const en = data.energyNorm[tokenIdx * L + layer] / 255.0;
            const brightness = ENERGY_FLOOR + (ENERGY_CEIL - ENERGY_FLOOR) * en;
            r *= brightness;
            g *= brightness;
            b *= brightness;

            rgb[dstIdx] = r;
            rgb[dstIdx + 1] = g;
            rgb[dstIdx + 2] = b;
        }
    }

    // Seam glow
    if (SEAM_GLOW_INTENSITY > 0) {
        for (let col = 0; col < W; col++) {
            const tokenIdx = tStart + (col - padLeft);
            if (tokenIdx < 0 || tokenIdx >= T) continue;
            const seamVal = data.seamScore[tokenIdx] / 255.0;

            for (let row = 0; row < L; row++) {
                const yNorm = row / L;
                const yCenter = 0.5;
                const vert = Math.exp(-Math.pow((yNorm - yCenter) / 0.28, 2));
                const glow = vert * seamVal * SEAM_GLOW_INTENSITY;

                const idx = (row * W + col) * 3;
                rgb[idx] += glow * SEAM_GLOW_COLOR[0];
                rgb[idx + 1] += glow * SEAM_GLOW_COLOR[1];
                rgb[idx + 2] += glow * SEAM_GLOW_COLOR[2];
            }
        }
    }

    // --- Metric highlight modes ---
    if (highlightMode) {
        applyMetricHighlight(rgb, tStart, tEnd, padLeft, W, L, T);
    }

    // --- Reference point mode ---
    if (refMode && refDistances) {
        applyReferenceMode(rgb, tStart, tEnd, padLeft, W, L, T);
    }

    // --- Color basis guidance mode (while selecting G or B) ---
    if (colorBasisSelecting && colorBasisGuidance) {
        applyColorBasisGuidance(rgb, tStart, tEnd, padLeft, W, L, T);
    }
    // --- Color basis mode (finalized) ---
    else if (colorBasisMode && colorBasisResult) {
        applyColorBasisResult(rgb, tStart, tEnd, padLeft, W, L, T);
    }

    return rgb;
}

function applyMetricHighlight(rgb, tStart, tEnd, padLeft, W, L, T) {
    const tintR = highlightMode === 'energy' ? 0.3 : 0.2;
    const tintG = highlightMode === 'energy' ? 0.8 : 1.0;
    const tintB = highlightMode === 'energy' ? 1.0 : 0.4;

    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;

        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;
            const idx = (row * W + col) * 3;

            // Luminance of current color
            const lum = 0.299 * rgb[idx] + 0.587 * rgb[idx+1] + 0.114 * rgb[idx+2];

            // Get metric value
            let metric;
            if (highlightMode === 'energy') {
                metric = data.energyNorm[tokenIdx * L + layer] / 255.0;
            } else {
                metric = data.sparsityNorm[tokenIdx * L + layer] / 255.0;
            }

            const blend = metric;
            const heat_r = blend * tintR;
            const heat_g = blend * tintG;
            const heat_b = blend * tintB;

            rgb[idx] = lum * 0.3 + heat_r * 0.7 * (0.3 + 0.7 * blend);
            rgb[idx+1] = lum * 0.3 + heat_g * 0.7 * (0.3 + 0.7 * blend);
            rgb[idx+2] = lum * 0.3 + heat_b * 0.7 * (0.3 + 0.7 * blend);
        }
    }
}

function applyReferenceMode(rgb, tStart, tEnd, padLeft, W, L, T) {
    // Find quantile bounds for normalization
    const visibleDists = [];
    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;
        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;
            visibleDists.push(refDistances[tokenIdx * L + layer]);
        }
    }
    visibleDists.sort((a, b) => a - b);
    const dLo = visibleDists[Math.floor(visibleDists.length * 0.01)] || 0;
    const dHi = visibleDists[Math.floor(visibleDists.length * 0.95)] || 1;

    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;

        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;
            const idx = (row * W + col) * 3;

            const dist = refDistances[tokenIdx * L + layer];
            const distNorm = Math.max(0, Math.min(1, (dist - dLo) / (dHi - dLo + 1e-10)));
            const sim = 1.0 - distNorm;

            // Warm (close) to cool (far)
            const r = sim * 1.0 + (1 - sim) * 0.1;
            const g = sim * 0.9 + (1 - sim) * 0.2;
            const b = sim * 0.5 + (1 - sim) * 0.5;

            const bright = 0.3 + 0.7 * sim;
            rgb[idx] = r * bright;
            rgb[idx+1] = g * bright;
            rgb[idx+2] = b * bright;

            // Mark reference point
            if (tokenIdx === refToken && layer === refLayer) {
                rgb[idx] = 1; rgb[idx+1] = 1; rgb[idx+2] = 1;
            }
        }
    }
}

function applyTurbulence(rgb, tStart, tEnd, padLeft, W, L) {
    if (TURBULENCE_AMP <= 0 || noiseTextures.length === 0) return;
    const T = data.T;

    const idxA = Math.floor(turbulencePhase) % noiseTextures.length;
    const idxB = (idxA + 1) % noiseTextures.length;
    const frac = turbulencePhase - Math.floor(turbulencePhase);

    for (let row = 0; row < L; row++) {
        for (let col = 0; col < W; col++) {
            const tokenIdx = tStart + (col - padLeft);
            if (tokenIdx < 0 || tokenIdx >= T) continue;

            const layer = L - 1 - row;
            const delta = data.deltaNorm[tokenIdx * L + layer] / 255.0;

            const nIdx = row * W + col;
            const noise = noiseTextures[idxA][nIdx] * (1 - frac) + noiseTextures[idxB][nIdx] * frac;
            const turb = noise * delta * TURBULENCE_AMP;

            const rgbIdx = (row * W + col) * 3;
            rgb[rgbIdx] *= (1 + turb);
            rgb[rgbIdx+1] *= (1 + turb);
            rgb[rgbIdx+2] *= (1 + turb);
        }
    }
}

function applyGrain(rgb, tStart, tEnd, padLeft, W, L) {
    if (GRAIN_MAX <= 0 || grainTextures.length === 0) return;
    const T = data.T;

    const idxA = Math.floor(grainPhase) % grainTextures.length;
    const idxB = (idxA + 1) % grainTextures.length;
    const frac = grainPhase - Math.floor(grainPhase);

    for (let row = 0; row < L; row++) {
        for (let col = 0; col < W; col++) {
            const tokenIdx = tStart + (col - padLeft);
            if (tokenIdx < 0 || tokenIdx >= T) continue;

            const layer = L - 1 - row;
            const cosInst = data.cosInstability[tokenIdx * L + layer] / 255.0;

            const nIdx = row * W + col;
            const grain = grainTextures[idxA][nIdx] * (1 - frac) + grainTextures[idxB][nIdx] * frac;
            const g = grain * GRAIN_MAX;

            const rgbIdx = (row * W + col) * 3;
            rgb[rgbIdx] *= (1 + g * cosInst);
            rgb[rgbIdx+1] *= (1 + g * cosInst);
            rgb[rgbIdx+2] *= (1 + g * cosInst);
        }
    }
}

/* ══════════════════════════════════════════════════════════
   COLOR BASIS MODE
   ══════════════════════════════════════════════════════════ */

function computeReferenceDistances(refT, refL) {
    const { T, L, D, jl } = data;
    const distances = new Float32Array(T * L);
    const refOffset = (refT * L + refL) * D;

    for (let t = 0; t < T; t++) {
        for (let l = 0; l < L; l++) {
            const offset = (t * L + l) * D;
            let sumSq = 0;
            for (let d = 0; d < D; d++) {
                const diff = jl[offset + d] - jl[refOffset + d];
                sumSq += diff * diff;
            }
            distances[t * L + l] = Math.sqrt(sumSq);
        }
    }
    return distances;
}

function getJLVector(t, l) {
    const { L, D, jl } = data;
    const offset = (t * L + l) * D;
    const vec = new Float32Array(D);
    for (let d = 0; d < D; d++) vec[d] = jl[offset + d];
    return vec;
}

function vecDot(a, b) {
    let s = 0;
    for (let i = 0; i < a.length; i++) s += a[i] * b[i];
    return s;
}

function vecNorm(v) { return Math.sqrt(vecDot(v, v)); }

function vecScale(v, s) {
    const r = new Float32Array(v.length);
    for (let i = 0; i < v.length; i++) r[i] = v[i] * s;
    return r;
}

function vecSub(a, b) {
    const r = new Float32Array(a.length);
    for (let i = 0; i < a.length; i++) r[i] = a[i] - b[i];
    return r;
}

function vecAdd(a, b) {
    const r = new Float32Array(a.length);
    for (let i = 0; i < a.length; i++) r[i] = a[i] + b[i];
    return r;
}

function vecMean(vectors) {
    const D = vectors[0].length;
    const mean = new Float32Array(D);
    for (const v of vectors) {
        for (let d = 0; d < D; d++) mean[d] += v[d];
    }
    for (let d = 0; d < D; d++) mean[d] /= vectors.length;
    return mean;
}

function computeGroupVector(group) {
    const srcVecs = group.sourceCells.map(([t, l]) => getJLVector(t, l));
    const srcMean = vecMean(srcVecs);
    if (group.contrastCells.length > 0) {
        const conVecs = group.contrastCells.map(([t, l]) => getJLVector(t, l));
        const conMean = vecMean(conVecs);
        return vecSub(srcMean, conMean);
    }
    return srcMean;
}

function finalizeColorBasis() {
    const EPS = 1e-6;

    const v1 = computeGroupVector(colorBasisGroups[0]);
    const v2 = computeGroupVector(colorBasisGroups[1]);
    const v3 = computeGroupVector(colorBasisGroups[2]);

    // Gram-Schmidt
    const n1 = vecNorm(v1);
    if (n1 < EPS) return false;
    let e1 = vecScale(v1, 1 / n1);

    let v2Orth = vecSub(v2, vecScale(e1, vecDot(v2, e1)));
    const n2 = vecNorm(v2Orth);
    if (n2 < EPS) return false;
    let e2 = vecScale(v2Orth, 1 / n2);

    let v3Orth = vecSub(vecSub(v3, vecScale(e1, vecDot(v3, e1))), vecScale(e2, vecDot(v3, e2)));
    const n3 = vecNorm(v3Orth);
    if (n3 < EPS) return false;
    let e3 = vecScale(v3Orth, 1 / n3);

    // Sign flip: ensure source centroids project positively
    const src1Mean = vecMean(colorBasisGroups[0].sourceCells.map(([t, l]) => getJLVector(t, l)));
    const src2Mean = vecMean(colorBasisGroups[1].sourceCells.map(([t, l]) => getJLVector(t, l)));
    const src3Mean = vecMean(colorBasisGroups[2].sourceCells.map(([t, l]) => getJLVector(t, l)));
    if (vecDot(src1Mean, e1) < 0) e1 = vecScale(e1, -1);
    if (vecDot(src2Mean, e2) < 0) e2 = vecScale(e2, -1);
    if (vecDot(src3Mean, e3) < 0) e3 = vecScale(e3, -1);

    // Project all JL vectors
    const { T, L, D, jl } = data;
    const rawR = new Float32Array(T * L);
    const rawG = new Float32Array(T * L);
    const rawB = new Float32Array(T * L);

    for (let t = 0; t < T; t++) {
        for (let l = 0; l < L; l++) {
            const offset = (t * L + l) * D;
            let rr = 0, gg = 0, bb = 0;
            for (let d = 0; d < D; d++) {
                rr += jl[offset + d] * e1[d];
                gg += jl[offset + d] * e2[d];
                bb += jl[offset + d] * e3[d];
            }
            rawR[t * L + l] = rr;
            rawG[t * L + l] = gg;
            rawB[t * L + l] = bb;
        }
    }

    // Global normalization
    function globalNorm(arr) {
        const sorted = Float32Array.from(arr).sort();
        const lo = sorted[Math.floor(sorted.length * 0.02)];
        const hi = sorted[Math.floor(sorted.length * 0.98)];
        const mid = (lo + hi) / 2;
        const spread = (hi - lo) / 2 + 1e-10;
        const result = new Float32Array(arr.length);
        for (let i = 0; i < arr.length; i++) {
            result[i] = Math.max(0, Math.min(1, (arr[i] - mid) / spread * 0.5 + 0.5));
        }
        return result;
    }

    colorBasisResult = {
        e1, e2, e3,
        projR: globalNorm(rawR),
        projG: globalNorm(rawG),
        projB: globalNorm(rawB),
    };
    return true;
}

function computePerpToDirection(direction) {
    const { T, L, D, jl } = data;
    const dNorm = vecNorm(direction) + 1e-10;
    const dUnit = vecScale(direction, 1 / dNorm);

    const perp = new Float32Array(T * L);
    for (let t = 0; t < T; t++) {
        for (let l = 0; l < L; l++) {
            const offset = (t * L + l) * D;
            let dot = 0, norm2 = 0;
            for (let d = 0; d < D; d++) {
                dot += jl[offset + d] * dUnit[d];
                norm2 += jl[offset + d] * jl[offset + d];
            }
            const layerNorm = Math.sqrt(norm2) + 1e-10;
            perp[t * L + l] = 1.0 - Math.abs(dot / layerNorm);
        }
    }
    return perp;
}

function computePerpToPlane(dir1, dir2) {
    const { T, L, D, jl } = data;

    // Orthonormalize dir1, dir2
    const v1Norm = vecNorm(dir1) + 1e-10;
    const v1Unit = vecScale(dir1, 1 / v1Norm);
    const v2Proj = vecSub(dir2, vecScale(v1Unit, vecDot(dir2, v1Unit)));
    const v2Norm = vecNorm(v2Proj) + 1e-10;
    const v2Orth = vecScale(v2Proj, 1 / v2Norm);

    const perp = new Float32Array(T * L);
    for (let t = 0; t < T; t++) {
        for (let l = 0; l < L; l++) {
            const offset = (t * L + l) * D;
            let norm2 = 0, p1 = 0, p2 = 0;
            for (let d = 0; d < D; d++) {
                const v = jl[offset + d];
                norm2 += v * v;
                p1 += v * v1Unit[d];
                p2 += v * v2Orth[d];
            }
            const layerNorm = Math.sqrt(norm2) + 1e-10;
            const projV1 = p1 / layerNorm;
            const projV2 = p2 / layerNorm;
            const inPlaneSq = projV1 * projV1 + projV2 * projV2;
            perp[t * L + l] = Math.sqrt(Math.max(0, Math.min(1, 1 - inPlaneSq)));
        }
    }
    return perp;
}

function applyColorBasisGuidance(rgb, tStart, tEnd, padLeft, W, L, T) {
    // Quantile normalize guidance
    const visibleVals = [];
    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;
        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;
            visibleVals.push(colorBasisGuidance[tokenIdx * L + layer]);
        }
    }
    visibleVals.sort((a, b) => a - b);
    const lo = visibleVals[Math.floor(visibleVals.length * 0.05)] || 0;
    const hi = visibleVals[Math.floor(visibleVals.length * 0.95)] || 1;

    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;

        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;
            const idx = (row * W + col) * 3;
            const val = colorBasisGuidance[tokenIdx * L + layer];
            const norm = Math.max(0, Math.min(1, (val - lo) / (hi - lo + 1e-10)));
            rgb[idx] = norm;
            rgb[idx+1] = norm;
            rgb[idx+2] = norm;
        }
    }
}

function applyColorBasisResult(rgb, tStart, tEnd, padLeft, W, L, T) {
    for (let col = 0; col < W; col++) {
        const tokenIdx = tStart + (col - padLeft);
        if (tokenIdx < 0 || tokenIdx >= T) continue;

        for (let row = 0; row < L; row++) {
            const layer = L - 1 - row;
            const idx = (row * W + col) * 3;
            const flatIdx = tokenIdx * L + layer;
            rgb[idx] = colorBasisResult.projR[flatIdx];
            rgb[idx+1] = colorBasisResult.projG[flatIdx];
            rgb[idx+2] = colorBasisResult.projB[flatIdx];
        }
    }
}

function startColorBasisSelection() {
    colorBasisSelecting = true;
    colorBasisCurrentIdx = 0;
    colorBasisGroups = [
        { sourceCells: [], contrastCells: [], undoStack: [] },
    ];
    colorBasisResult = null;
    colorBasisGuidance = null;
    colorBasisMode = false;
    cachedTEnd = -1;
}

function advanceColorBasis() {
    if (!colorBasisSelecting) return;

    const group = colorBasisGroups[colorBasisCurrentIdx];
    if (group.sourceCells.length === 0) return;

    if (colorBasisCurrentIdx < 2) {
        colorBasisCurrentIdx++;
        if (colorBasisGroups.length <= colorBasisCurrentIdx) {
            colorBasisGroups.push({ sourceCells: [], contrastCells: [], undoStack: [] });
        }

        // Update guidance
        if (colorBasisCurrentIdx === 1) {
            const rVec = computeGroupVector(colorBasisGroups[0]);
            colorBasisGuidance = computePerpToDirection(rVec);
        } else if (colorBasisCurrentIdx === 2) {
            const rVec = computeGroupVector(colorBasisGroups[0]);
            const gVec = computeGroupVector(colorBasisGroups[1]);
            colorBasisGuidance = computePerpToPlane(rVec, gVec);
        }
        cachedTEnd = -1;
    } else {
        // Finalize
        if (finalizeColorBasis()) {
            colorBasisSelecting = false;
            colorBasisMode = true;
            colorBasisGuidance = null;
            cachedTEnd = -1;
        }
    }
}

function undoColorBasis() {
    if (!colorBasisSelecting) return;
    const group = colorBasisGroups[colorBasisCurrentIdx];
    if (group.undoStack.length === 0) return;

    const [kind, cell] = group.undoStack.pop();
    const list = kind === 'source' ? group.sourceCells : group.contrastCells;
    const idx = list.findIndex(([t, l]) => t === cell[0] && l === cell[1]);
    if (idx !== -1) list.splice(idx, 1);
    cachedTEnd = -1;
}

function clearColorBasis() {
    colorBasisMode = false;
    colorBasisSelecting = false;
    colorBasisCurrentIdx = 0;
    colorBasisGroups = [];
    colorBasisResult = null;
    colorBasisGuidance = null;
    cachedTEnd = -1;
}

/* ══════════════════════════════════════════════════════════
   UI OVERLAYS
   ══════════════════════════════════════════════════════════ */

function renderTurnMarkers(xOff, yOff, newW, newH, cellWScaled, tStart, tEnd, padLeft, W, L) {
    for (const tb of data.turns) {
        if (tb.token_start < tStart || tb.token_start > tEnd + 1) continue;

        const winPos = padLeft + (tb.token_start - tStart);
        const lineX = xOff + winPos * cellWScaled;

        const color = tb.role === 'user' ? 'rgba(120, 180, 255, 0.6)' :
                      tb.role === 'assistant' ? 'rgba(255, 200, 100, 0.6)' :
                      'rgba(100, 100, 120, 0.6)';

        ctx.strokeStyle = color;
        ctx.lineWidth = 1;

        if (tb.role === 'user') {
            // Dashed line
            ctx.setLineDash([8, 4]);
        } else {
            ctx.setLineDash([]);
        }

        ctx.beginPath();
        ctx.moveTo(lineX, yOff);
        ctx.lineTo(lineX, yOff + newH);
        ctx.stroke();
        ctx.setLineDash([]);

        // Turn label
        ctx.fillStyle = color;
        ctx.font = '10px monospace';
        ctx.fillText(`T${tb.turn}`, lineX + 3, yOff - 4);
    }
}

function renderColorBasisMarkers(xOff, yOff, cellWScaled, cellHScaled, tStart, tEnd, padLeft, L) {
    const BRIGHT = ['rgb(255,60,60)', 'rgb(60,255,60)', 'rgb(60,60,255)'];
    const DIM = ['rgb(160,40,40)', 'rgb(40,160,40)', 'rgb(40,40,160)'];

    for (let gIdx = 0; gIdx < colorBasisGroups.length && gIdx < 3; gIdx++) {
        const group = colorBasisGroups[gIdx];

        // Source cells
        for (const [t, l] of group.sourceCells) {
            if (t < tStart || t > tEnd) continue;
            const winCol = padLeft + (t - tStart);
            const winRow = L - 1 - l;
            const sx = xOff + winCol * cellWScaled;
            const sy = yOff + winRow * cellHScaled;
            ctx.strokeStyle = BRIGHT[gIdx];
            ctx.lineWidth = 2;
            ctx.strokeRect(sx, sy, cellWScaled, cellHScaled);
            // Plus sign
            const cx = sx + cellWScaled / 2, cy = sy + cellHScaled / 2;
            const half = Math.min(cellWScaled, cellHScaled) / 4;
            ctx.beginPath();
            ctx.moveTo(cx - half, cy); ctx.lineTo(cx + half, cy);
            ctx.moveTo(cx, cy - half); ctx.lineTo(cx, cy + half);
            ctx.stroke();
        }

        // Contrast cells
        for (const [t, l] of group.contrastCells) {
            if (t < tStart || t > tEnd) continue;
            const winCol = padLeft + (t - tStart);
            const winRow = L - 1 - l;
            const sx = xOff + winCol * cellWScaled;
            const sy = yOff + winRow * cellHScaled;
            ctx.strokeStyle = DIM[gIdx];
            ctx.lineWidth = 2;
            ctx.strokeRect(sx, sy, cellWScaled, cellHScaled);
            // Minus sign
            const cx = sx + cellWScaled / 2, cy = sy + cellHScaled / 2;
            const half = Math.min(cellWScaled, cellHScaled) / 4;
            ctx.beginPath();
            ctx.moveTo(cx - half, cy); ctx.lineTo(cx + half, cy);
            ctx.stroke();
        }
    }
}

function renderInspectorCrosshairs(xOff, yOff, newW, newH, cellWScaled, cellHScaled, tStart, tEnd, padLeft, L) {
    const relT = (inspectorToken - tStart + padLeft + 0.5) / TOKENS_VISIBLE;
    const relL = 1.0 - (inspectorLayer + 0.5) / L;
    const crossX = xOff + relT * newW;
    const crossY = yOff + relL * newH;

    ctx.strokeStyle = 'rgba(255, 200, 100, 0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(crossX, yOff); ctx.lineTo(crossX, yOff + newH);
    ctx.moveTo(xOff, crossY); ctx.lineTo(xOff + newW, crossY);
    ctx.stroke();
}

function updateRoleBar(vizX, vizW, cellWScaled, tStart, tEnd, padLeft, W, L) {
    const bar = document.getElementById('role-bar');
    bar.innerHTML = '';

    if (!showTurnMarkers || !data || data.turns.length === 0) return;

    // vizGeom is already in CSS pixels
    const dispXOff = vizGeom.xOff;
    const dispCellW = vizGeom.w / TOKENS_VISIBLE;

    for (const tb of data.turns) {
        const visStart = Math.max(tb.token_start, tStart);
        const visEnd = Math.min(tb.token_end, tEnd + 1);
        if (visStart >= visEnd) continue;

        const winStart = padLeft + (visStart - tStart);
        const winEnd = padLeft + (visEnd - tStart);

        const x1 = dispXOff + winStart * dispCellW;
        const x2 = dispXOff + winEnd * dispCellW;

        const div = document.createElement('div');
        div.style.cssText = `position:absolute;left:${x1}px;top:0;width:${x2-x1}px;height:100%;`;

        if (tb.role === 'user') div.style.background = 'rgba(120, 180, 255, 0.4)';
        else if (tb.role === 'assistant') div.style.background = 'rgba(255, 200, 100, 0.4)';
        else div.style.background = 'rgba(100, 100, 120, 0.3)';

        bar.appendChild(div);
    }
}

function updateHeader() {
    const tEnd = Math.min(Math.floor(tokenCursor), data.T - 1);
    document.getElementById('speed-display').textContent =
        `${playing ? '>' : '||'} ${(playbackSpeed).toFixed(1)}x`;
    document.getElementById('position-display').textContent =
        `${tEnd}/${data.T}`;

    let mode = '';
    if (colorBasisSelecting) mode = `C:${['R','G','B'][colorBasisCurrentIdx]}`;
    else if (colorBasisMode) mode = 'C:active';
    else if (refMode) mode = 'P:ref';
    else if (highlightMode) mode = `M:${highlightMode}`;
    document.getElementById('mode-display').textContent = mode;
}

function updateSessionName() {
    document.getElementById('session-name').textContent =
        `${currentSessionIdx + 1}. ${data.displayName} (${data.T} tokens)`;
}

function updateTokenStrip(tEnd) {
    const strip = document.getElementById('token-strip');
    if (playing) {
        strip.classList.add('hidden');
        return;
    }
    strip.classList.remove('hidden');

    if (!data.tokenPieces) { strip.textContent = `t=${tEnd}`; return; }

    const t = Math.min(tEnd, data.T - 1);
    const radius = 25;
    const lo = Math.max(0, t - radius);
    const hi = Math.min(data.T, t + radius + 1);

    let html = '';
    for (let i = lo; i < hi; i++) {
        let piece = data.tokenPieces[i] || '';
        piece = piece.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        if (i === t) {
            html += `<span style="color:var(--amber);font-weight:bold;text-decoration:underline">${piece}</span>`;
        } else {
            const opacity = Math.max(0.3, 1 - Math.abs(i - t) / radius);
            html += `<span style="opacity:${opacity}">${piece}</span>`;
        }
    }

    strip.innerHTML = html;
}

function updateColorBasisStatus() {
    const el = document.getElementById('color-basis-status');
    if (colorBasisSelecting) {
        const axis = ['RED', 'GREEN', 'BLUE'][colorBasisCurrentIdx];
        const group = colorBasisGroups[colorBasisCurrentIdx];
        const src = group ? group.sourceCells.length : 0;
        const con = group ? group.contrastCells.length : 0;
        el.textContent = `Selecting ${axis} axis: ${src} source, ${con} contrast | Click=source, Shift+Click=contrast, Enter=confirm, Z=undo, Esc=cancel`;
        el.style.display = 'block';
    } else if (colorBasisMode) {
        el.textContent = 'Custom Color Basis active | Press C to clear';
        el.style.display = 'block';
    } else {
        el.style.display = 'none';
    }
}

/* ══════════════════════════════════════════════════════════
   TEXT PANEL
   ══════════════════════════════════════════════════════════ */

function buildTextPanel() {
    const panel = document.getElementById('text-panel');
    if (!data || !data.tokenPieces) {
        panel.innerHTML = '<div style="color:var(--dim);padding:20px;">No text data</div>';
        return;
    }

    let html = '';
    for (let i = 0; i < data.T; i++) {
        let piece = data.tokenPieces[i] || '';
        // Escape HTML
        piece = piece.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // Handle newlines
        piece = piece.replace(/\n/g, '<br>');

        const role = data.tokenRoles[i] || '';
        const roleClass = role || 'default';
        html += `<span class="token-span ${roleClass}" data-t="${i}">${piece}</span>`;
    }
    panel.innerHTML = html;
}

function scrollTextPanel(tStart, tEnd) {
    if (!showTextPanel || !data) return;

    const panel = document.getElementById('text-panel');
    const tMid = Math.floor((tStart + tEnd) / 2);

    // Find the span for the mid token and the previous current
    const spans = panel.querySelectorAll('.token-span');
    const prevCurrent = panel.querySelector('.token-span.current');
    if (prevCurrent) prevCurrent.classList.remove('current');

    // Mark the current token
    const currentSpan = panel.querySelector(`.token-span[data-t="${tMid}"]`);
    if (currentSpan) {
        currentSpan.classList.add('current');
        // Smooth scroll to keep it visible
        const panelRect = panel.getBoundingClientRect();
        const spanRect = currentSpan.getBoundingClientRect();
        const spanCenter = spanRect.top + spanRect.height / 2;
        const panelCenter = panelRect.top + panelRect.height / 2;

        if (Math.abs(spanCenter - panelCenter) > panelRect.height * 0.3) {
            currentSpan.scrollIntoView({ block: 'center', behavior: 'auto' });
        }
    }
}

/* ══════════════════════════════════════════════════════════
   INSPECTOR
   ══════════════════════════════════════════════════════════ */

function updateInspector(mx, my) {
    if (!data || !showInspector) {
        document.getElementById('inspector').style.display = 'none';
        inspectorToken = null;
        inspectorLayer = null;
        return;
    }

    // Convert screen coords to token/layer
    const result = screenToTokenLayer(mx, my);
    if (!result) {
        document.getElementById('inspector').style.display = 'none';
        inspectorToken = null;
        inspectorLayer = null;
        return;
    }

    const [tokenIdx, layerIdx] = result;
    inspectorToken = tokenIdx;
    inspectorLayer = layerIdx;

    // Build tooltip content
    let html = `<div class="label">Token ${tokenIdx}, Layer ${layerIdx}</div>`;

    if (data.tokenPieces && tokenIdx < data.tokenPieces.length) {
        let piece = data.tokenPieces[tokenIdx].replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html += `<div class="value">"${piece}"</div>`;
    }

    // Turn info
    const turn = data.turns.find(tb => tokenIdx >= tb.token_start && tokenIdx < tb.token_end);
    if (turn) {
        const pos = tokenIdx - turn.token_start;
        const len = turn.token_end - turn.token_start;
        html += `<div class="value">Turn ${turn.turn} (${turn.role}) ${pos}/${len}</div>`;
    }

    html += `<br>`;
    const en = data.energyNorm[tokenIdx * data.L + layerIdx] / 255;
    const dn = data.deltaNorm[tokenIdx * data.L + layerIdx] / 255;
    const ci = data.cosInstability[tokenIdx * data.L + layerIdx] / 255;
    const sp = data.sparsityNorm[tokenIdx * data.L + layerIdx] / 255;
    const seam = data.seamScore[tokenIdx] / 255;

    html += `<div class="value">energy:  ${en.toFixed(3)}</div>`;
    html += `<div class="value">delta:   ${dn.toFixed(3)}</div>`;
    html += `<div class="value">cos_inst: ${ci.toFixed(3)}</div>`;
    html += `<div class="value">sparsity: ${sp.toFixed(3)}</div>`;
    html += `<div class="value">seam:    ${seam.toFixed(3)}</div>`;

    const el = document.getElementById('inspector');
    el.innerHTML = html;
    el.style.display = 'block';

    // Position near mouse
    let tx = mx + 20;
    let ty = my - 60;
    if (tx + 200 > window.innerWidth) tx = mx - 200;
    ty = Math.max(10, Math.min(window.innerHeight - 200, ty));
    el.style.left = tx + 'px';
    el.style.top = ty + 'px';
}

function screenToTokenLayer(mx, my) {
    if (!vizGeom.w || !data) return null;

    // Convert page coordinates to canvas-wrapper-relative
    const wrapperRect = document.getElementById('canvas-wrapper').getBoundingClientRect();
    const relX = mx - wrapperRect.left;
    const relY = my - wrapperRect.top;

    const { xOff, yOff, w, h, padLeft, tStart } = vizGeom;
    const L = data.L;
    const W = TOKENS_VISIBLE;

    // Check if inside viz area
    if (relX < xOff || relX >= xOff + w || relY < yOff || relY >= yOff + h) {
        return null;
    }

    const normX = (relX - xOff) / w;
    const normY = (relY - yOff) / h;

    const tokInWin = Math.floor(normX * W);
    if (tokInWin < padLeft) return null;

    let tokenIdx = tStart + (tokInWin - padLeft);
    tokenIdx = Math.min(tokenIdx, data.T - 1);

    let layerIdx = Math.floor((1.0 - normY) * L);
    layerIdx = Math.max(0, Math.min(L - 1, layerIdx));

    return [tokenIdx, layerIdx];
}

/* ══════════════════════════════════════════════════════════
   SESSION PICKER
   ══════════════════════════════════════════════════════════ */

function buildSessionPicker() {
    const list = document.getElementById('session-list');
    let html = '<h2>Dream Sessions</h2>';
    for (let i = 0; i < sessions.length; i++) {
        const s = sessions[i];
        const active = i === currentSessionIdx ? 'active' : '';
        html += `<div class="session-item ${active}" onclick="switchSession(${i}); toggleSessionPicker()">
            <span class="num">${i + 1}</span>
            <span class="name">${s.display_name}</span>
            <span class="info">${s.n_tokens} tokens</span>
        </div>`;
    }
    list.innerHTML = html;
}

async function switchSession(idx) {
    if (idx < 0 || idx >= sessions.length) return;
    await loadSession(idx);
}

/* ══════════════════════════════════════════════════════════
   INPUT HANDLING
   ══════════════════════════════════════════════════════════ */

function toggleHelp() {
    showHelp = !showHelp;
    document.getElementById('help-overlay').classList.toggle('hidden', !showHelp);
}

function toggleSessionPicker() {
    showSessionPicker = !showSessionPicker;
    document.getElementById('session-picker').classList.toggle('hidden', !showSessionPicker);
}

document.addEventListener('keydown', async (e) => {
    // Close overlays first
    if (showHelp && e.key !== 'h' && e.key !== 'H') {
        if (e.key === 'Escape' || e.key === ' ') { toggleHelp(); e.preventDefault(); return; }
    }
    if (showSessionPicker) {
        if (e.key === 'Escape' || e.key === 's' || e.key === 'S') { toggleSessionPicker(); e.preventDefault(); return; }
        // Number keys in picker
        if (e.key >= '1' && e.key <= '9') {
            const idx = parseInt(e.key) - 1;
            if (idx < sessions.length) { await switchSession(idx); toggleSessionPicker(); }
            e.preventDefault(); return;
        }
    }

    if (!data) return;

    // Color basis Escape
    if (e.key === 'Escape') {
        if (colorBasisSelecting) { clearColorBasis(); e.preventDefault(); return; }
        if (refMode) { refMode = false; refDistances = null; cachedTEnd = -1; e.preventDefault(); return; }
    }

    switch (e.key) {
        case ' ':
            playing = !playing;
            e.preventDefault();
            break;
        case 'ArrowLeft':
            if (!playing) { tokenCursor = Math.max(0, Math.floor(tokenCursor) - 1); cachedTEnd = -1; }
            e.preventDefault();
            break;
        case 'ArrowRight':
            if (!playing) { tokenCursor = Math.min(data.T - 1, Math.floor(tokenCursor) + 1); cachedTEnd = -1; }
            e.preventDefault();
            break;
        case 'ArrowUp':
            playbackSpeed = Math.min(16, playbackSpeed * 1.5);
            e.preventDefault();
            break;
        case 'ArrowDown':
            playbackSpeed = Math.max(0.1, playbackSpeed / 1.5);
            e.preventDefault();
            break;
        case 'Tab':
            showTextPanel = !showTextPanel;
            document.getElementById('text-panel').classList.toggle('hidden', !showTextPanel);
            setTimeout(resizeCanvas, 50);
            e.preventDefault();
            break;
        case 't': case 'T':
            showTurnMarkers = !showTurnMarkers;
            cachedTEnd = -1;
            break;
        case 'i': case 'I':
            showInspector = !showInspector;
            if (!showInspector) document.getElementById('inspector').style.display = 'none';
            break;
        case 'h': case 'H':
            toggleHelp();
            break;
        case 's': case 'S':
            toggleSessionPicker();
            break;
        case 'm': case 'M':
            highlightIdx = (highlightIdx + 1) % HIGHLIGHT_MODES.length;
            highlightMode = HIGHLIGHT_MODES[highlightIdx];
            cachedTEnd = -1;
            break;
        case 'p': case 'P':
            if (!refMode) {
                // Set reference at current playhead center
                const tEnd = Math.min(Math.floor(tokenCursor), data.T - 1);
                const midLayer = Math.floor(data.L / 2);
                refToken = tEnd;
                refLayer = midLayer;
                refDistances = computeReferenceDistances(tEnd, midLayer);
                refMode = true;
            } else {
                refMode = false;
                refDistances = null;
            }
            cachedTEnd = -1;
            break;
        case 'c': case 'C':
            if (colorBasisMode || colorBasisSelecting) {
                clearColorBasis();
            } else {
                startColorBasisSelection();
            }
            break;
        case 'Enter':
            if (colorBasisSelecting) { advanceColorBasis(); e.preventDefault(); }
            break;
        case 'z': case 'Z':
            if (colorBasisSelecting) { undoColorBasis(); }
            break;
        default:
            // Number keys for session switching
            if (e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                if (idx < sessions.length) { await switchSession(idx); }
            }
            break;
    }
});

// Mouse events
document.addEventListener('mousemove', (e) => {
    updateInspector(e.pageX, e.pageY);
});

document.getElementById('canvas-wrapper').addEventListener('click', (e) => {
    if (!data) return;

    const result = screenToTokenLayer(e.pageX, e.pageY);
    if (!result) return;
    const [tokenIdx, layerIdx] = result;

    // Color basis click
    if (colorBasisSelecting) {
        const group = colorBasisGroups[colorBasisCurrentIdx];
        if (e.shiftKey) {
            group.contrastCells.push([tokenIdx, layerIdx]);
            group.undoStack.push(['contrast', [tokenIdx, layerIdx]]);
        } else {
            group.sourceCells.push([tokenIdx, layerIdx]);
            group.undoStack.push(['source', [tokenIdx, layerIdx]]);
        }
        cachedTEnd = -1;
        return;
    }

    // Reference point click
    if (refMode || e.altKey) {
        refToken = tokenIdx;
        refLayer = layerIdx;
        refDistances = computeReferenceDistances(tokenIdx, layerIdx);
        refMode = true;
        cachedTEnd = -1;
        return;
    }
});

// Window resize
window.addEventListener('resize', () => {
    resizeCanvas();
});

// Prevent default for arrow keys globally
window.addEventListener('keydown', (e) => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Tab'].includes(e.key)) {
        e.preventDefault();
    }
});

/* ══════════════════════════════════════════════════════════
   INITIALIZATION
   ══════════════════════════════════════════════════════════ */

async function init() {
    try {
        await loadSessionIndex();
        buildSessionPicker();
        resizeCanvas();
        await loadSession(0);
        requestAnimationFrame(renderFrame);
    } catch (err) {
        document.getElementById('loading-status').textContent = `Error: ${err.message}`;
        console.error(err);
    }
}

init();
</script>

</body>
</html>
